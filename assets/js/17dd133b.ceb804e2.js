"use strict";(self.webpackChunkchisel_lang=self.webpackChunkchisel_lang||[]).push([[8316],{8203:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var s=i(4848),l=i(8453);const o={layout:"docs",title:"Frequently Asked Questions",section:"chisel3"},t="Frequently Asked Questions",r={id:"resources/faqs",title:"Frequently Asked Questions",description:"* Where should I start if I want to learn Chisel?",source:"@site/docs/resources/faqs.md",sourceDirName:"resources",slug:"/resources/faqs",permalink:"/docs/resources/faqs",draft:!1,unlisted:!1,editUrl:"https://github.com/chipsalliance/chisel/tree/main/docs/src/resources/faqs.md",tags:[],version:"current",frontMatter:{layout:"docs",title:"Frequently Asked Questions",section:"chisel3"},sidebar:"chiselSidebar",previous:{title:"Chisel Resources",permalink:"/docs/resources"}},a={},d=[{value:"Where should I start if I want to learn Chisel?",id:"where-should-i-start-if-i-want-to-learn-chisel",level:3},{value:"How do I do ... (e.g. like that in Verilog) in Chisel?",id:"how-do-i-do--eg-like-that-in-verilog-in-chisel",level:3},{value:"What versions of the various projects work together?",id:"what-versions-of-the-various-projects-work-together",level:3},{value:"How can I contribute to Chisel?",id:"how-can-i-contribute-to-chisel",level:3},{value:"Why DecoupledIO instead of ReadyValidIO?",id:"why-decoupledio-instead-of-readyvalidio",level:3},{value:"Why do I have to wrap module instantiations in <code>Module(...)</code>?",id:"why-do-i-have-to-wrap-module-instantiations-in-module",level:3},{value:"Why Chisel?",id:"why-chisel",level:3},{value:"Does Chisel support X and Z logic values",id:"does-chisel-support-x-and-z-logic-values",level:3},{value:"Get me Verilog",id:"get-me-verilog",level:3},{value:"Get me FIRRTL",id:"get-me-firrtl",level:3},{value:"Why doesn&#39;t Chisel tell me which wires aren&#39;t connected?",id:"why-doesnt-chisel-tell-me-which-wires-arent-connected",level:3},{value:"What does <code>Reference ... is not fully initialized.</code> mean?",id:"what-does-reference--is-not-fully-initialized-mean",level:3},{value:"Can I specify behavior before and after generated initial blocks?",id:"can-i-specify-behavior-before-and-after-generated-initial-blocks",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"frequently-asked-questions",children:"Frequently Asked Questions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#where-should-i-start-if-i-want-to-learn-chisel",children:"Where should I start if I want to learn Chisel?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#how-do-i-do--eg-like-that-in-verilog-in-chisel",children:"How do I ... in Chisel?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#what-versions-of-the-various-projects-work-together",children:"What versions of the various projects work together?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#how-can-i-contribute-to-chisel",children:"How can I contribute to Chisel?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#why-decoupledio-instead-of-readyvalidio",children:"Why DecoupledIO instead of ReadyValidIO?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"#why-do-i-have-to-wrap-module-instantiations-in-module",children:["Why do I have to wrap module instantiations in ",(0,s.jsx)(n.code,{children:"Module(...)"}),"?"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#why-chisel",children:"Why Chisel?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#does-chisel-support-x-and-z-logic-values",children:"Does Chisel support X and Z logic values?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#get-me-verilog",children:"I just want some Verilog; what do I do?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#get-me-firrtl",children:"I just want some FIRRTL; what do I do?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#why-doesnt-chisel-tell-me-which-wires-arent-connected",children:"Why doesn't Chisel tell me which wires aren't connected?"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"#what-does-reference--is-not-fully-initialized-mean",children:["What does ",(0,s.jsx)(n.code,{children:"Reference ... is not fully initialized."})," mean?"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#can-i-specify-behavior-before-and-after-generated-initial-blocks",children:"Can I specify behavior before and after generated initial blocks?"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"where-should-i-start-if-i-want-to-learn-chisel",children:"Where should I start if I want to learn Chisel?"}),"\n",(0,s.jsxs)(n.p,{children:["We recommend the ",(0,s.jsx)(n.a,{href:"https://github.com/freechipsproject/chisel-bootcamp",children:"Chisel Bootcamp"})," for getting started with Chisel."]}),"\n",(0,s.jsx)(n.h3,{id:"how-do-i-do--eg-like-that-in-verilog-in-chisel",children:"How do I do ... (e.g. like that in Verilog) in Chisel?"}),"\n",(0,s.jsxs)(n.p,{children:["See the ",(0,s.jsx)(n.a,{href:"../cookbooks/cookbook",children:"cookbooks"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"what-versions-of-the-various-projects-work-together",children:"What versions of the various projects work together?"}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"../appendix/versioning",children:"Chisel Project Versioning"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"how-can-i-contribute-to-chisel",children:"How can I contribute to Chisel?"}),"\n",(0,s.jsxs)(n.p,{children:["Check out the ",(0,s.jsx)(n.a,{href:"https://github.com/chipsalliance/chisel3#contributor-documentation",children:"Contributor Documentation"})," in the chisel3 repository."]}),"\n",(0,s.jsx)(n.h3,{id:"why-decoupledio-instead-of-readyvalidio",children:"Why DecoupledIO instead of ReadyValidIO?"}),"\n",(0,s.jsx)(n.p,{children:"There are multiple kinds of Ready/Valid interfaces that impose varying restrictions on the producers and consumers. Chisel currently provides the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://chisel.eecs.berkeley.edu/api/index.html#chisel3.util.DecoupledIO",children:"DecoupledIO"})," - No guarantees"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://chisel.eecs.berkeley.edu/api/index.html#chisel3.util.IrrevocableIO",children:"IrrevocableIO"})," - Producer promises to not change the value of 'bits' after a cycle where 'valid' is high and 'ready' is low. Additionally, once 'valid' is raised it will never be lowered until after 'ready' has also been raised."]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"why-do-i-have-to-wrap-module-instantiations-in-module",children:["Why do I have to wrap module instantiations in ",(0,s.jsx)(n.code,{children:"Module(...)"}),"?"]}),"\n",(0,s.jsx)(n.p,{children:"In short: Limitations of Scala"}),"\n",(0,s.jsxs)(n.p,{children:["Chisel Modules are written by defining a ",(0,s.jsx)(n.a,{href:"http://docs.scala-lang.org/tutorials/tour/classes.html",children:"Scala class"})," and implementing its constructor. As elaboration runs, Chisel constructs a hardware AST from these Modules. The compiler needs hooks to run before and after the actual construction of the Module object. In Scala, superclasses are fully initialized before subclasses, so by extending Module, Chisel has the ability to run some initialization code before the user's Module is constructed. However, there is no such hook to run after the Module object is initialized. By wrapping Module instantiations in the Module object's apply method (ie. ",(0,s.jsx)(n.code,{children:"Module(...)"}),"), Chisel is able to perform post-initialization actions. There is a ",(0,s.jsx)(n.a,{href:"https://issues.scala-lang.org/browse/SI-4330",children:"proposed solution"}),", so eventually this requirement will be lifted, but for now, wrap those Modules!"]}),"\n",(0,s.jsx)(n.h3,{id:"why-chisel",children:"Why Chisel?"}),"\n",(0,s.jsxs)(n.p,{children:["Please see ",(0,s.jsx)(n.a,{href:"../explanations/motivation",children:"Chisel Motivation"})]}),"\n",(0,s.jsx)(n.h3,{id:"does-chisel-support-x-and-z-logic-values",children:"Does Chisel support X and Z logic values"}),"\n",(0,s.jsxs)(n.p,{children:["Chisel does not directly support Verilog logic values ",(0,s.jsx)(n.code,{children:"x"})," ",(0,s.jsx)(n.em,{children:"unknown"})," and ",(0,s.jsx)(n.code,{children:"z"})," ",(0,s.jsx)(n.em,{children:"high-impedance"}),".  There are a number of reasons to want to avoid these values.  See:",(0,s.jsx)(n.a,{href:"http://infocenter.arm.com/help/topic/com.arm.doc.arp0009a/Verilog_X_Bugs.pdf",children:"The Dangers of Living With An X"})," and ",(0,s.jsx)(n.a,{href:"http://ieeexplore.ieee.org/document/7827620/",children:"Malicious LUT: A stealthy FPGA Trojan injected and triggered by the design flow"}),".  Chisel has its own eco-system of unit and functional testers that limit the need for ",(0,s.jsx)(n.code,{children:"x"})," and ",(0,s.jsx)(n.code,{children:"z"})," and their omission simplify language implementation, design, and testing.  The circuits created by chisel do not preclude developers from using ",(0,s.jsx)(n.code,{children:"x"})," and ",(0,s.jsx)(n.code,{children:"z"})," in downstream toolchains as they see fit."]}),"\n",(0,s.jsx)(n.h3,{id:"get-me-verilog",children:"Get me Verilog"}),"\n",(0,s.jsx)(n.p,{children:"I wrote a module and I want to see the Verilog; what do I do?"}),"\n",(0,s.jsx)(n.p,{children:"Here's a simple hello world module in a file HelloWorld.scala."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"package intro\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:'import chisel3._\nclass HelloWorld extends Module {\n  val io = IO(new Bundle{})\n  printf("hello world\\n")\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Add the following"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"import circt.stage.ChiselStage\nobject VerilogMain extends App {\n  ChiselStage.emitSystemVerilog(new HelloWorld)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now you can get some Verilog. Start sbt:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"bash> sbt\n> run-main intro.VerilogMain\n[info] Running intro.VerilogMain\n[info] [0.004] Elaborating design...\n[info] [0.100] Done elaborating.\n[success] Total time: 1 s, completed Jan 12, 2017 6:24:03 PM\n"})}),"\n",(0,s.jsx)(n.p,{children:"or as a one-liner:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"bash> sbt 'runMain intro.VerilogMain'\n"})}),"\n",(0,s.jsx)(n.p,{children:"After either of the above there will be a HelloWorld.v file in the current directory:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-verilog",children:"// Generated by CIRCT firtool-1.76.0\n\n// Users can define 'PRINTF_COND' to add an extra gate to prints.\n`ifndef PRINTF_COND_\n  `ifdef PRINTF_COND\n    `define PRINTF_COND_ (`PRINTF_COND)\n  `else  // PRINTF_COND\n    `define PRINTF_COND_ 1\n  `endif // PRINTF_COND\n`endif // not def PRINTF_COND_\nmodule HelloWorld(\t// faqs.md:11:7\n  input clock,\t// faqs.md:11:7\n        reset\t// faqs.md:11:7\n);\n\n  `ifndef SYNTHESIS\t// faqs.md:13:9\n    always @(posedge clock) begin\t// faqs.md:13:9\n      if ((`PRINTF_COND_) & ~reset)\t// faqs.md:13:9\n        $fwrite(32'h80000002, \"hello world\\n\");\t// faqs.md:13:9\n    end // always @(posedge)\n  `endif // not def SYNTHESIS\nendmodule\n\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can see additional options with"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"bash> sbt 'runMain intro.HelloWorld --help'\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will return a comprehensive usage line with available options."}),"\n",(0,s.jsx)(n.p,{children:"For example to place the output in a directory name buildstuff use"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"bash> sbt 'runMain intro.HelloWorld --target-dir buildstuff --top-name HelloWorld'\n"})}),"\n",(0,s.jsx)(n.p,{children:"Alternatively, you can also use the sbt console to invoke the Verilog driver:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'$ sbt\n> console\n[info] Starting scala interpreter...\nWelcome to Scala 2.12.13 (OpenJDK 64-Bit Server VM, Java 1.8.0_275).\nType in expressions for evaluation. Or try :help.\n\nscala> (new circt.stage.ChiselStage).emitSystemVerilog(new HelloWorld())\nchisel3.Driver.execute(Array[String](), () => new HelloWorld)\nElaborating design...\nDone elaborating.\nres1: String =\n"module HelloWorld(\n  input   clock,\n  input   reset\n);\n...\n'})}),"\n",(0,s.jsx)(n.p,{children:"As before, there should be a HelloWorld.v file in the current directory."}),"\n",(0,s.jsxs)(n.p,{children:["Note: Using the following, without the ",(0,s.jsx)(n.code,{children:"new"}),",\nwill ONLY return the string representation, and will not emit a ",(0,s.jsx)(n.code,{children:".v"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"ChiselStage.emitSystemVerilog(new HelloWorld())\n"})}),"\n",(0,s.jsx)(n.h3,{id:"get-me-firrtl",children:"Get me FIRRTL"}),"\n",(0,s.jsx)(n.p,{children:"If for some reason you don't want the Verilog (e.g. maybe you want to run some custom transformations before exporting to Verilog), then use something along these lines:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"package intro\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-scala",children:"\nimport chisel3._\nimport circt.stage.ChiselStage\n\nclass MyFirrtlModule extends Module {\n  val io = IO(new Bundle{})\n}\n\nobject FirrtlMain extends App {\n  ChiselStage.emitCHIRRTL(new MyFirrtlModule)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Run it with:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"sbt 'runMain intro.FirrtlMain'\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"FIRRTL version 4.0.0\ncircuit MyFirrtlModule :\n  public module MyFirrtlModule : @[faqs.md 64:7]\n    input clock : Clock @[faqs.md 64:7]\n    input reset : UInt<1> @[faqs.md 64:7]\n    output io : { } @[faqs.md 65:14]\n\n    skip\n\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"Alternatively, you can also use the sbt console to invoke the FIRRTL driver directly (replace MyFirrtlModule with your module name):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"$ sbt\n> console\n[info] Starting scala interpreter...\nWelcome to Scala 2.12.13 (OpenJDK 64-Bit Server VM, Java 1.8.0_275).\nType in expressions for evaluation. Or try :help.\n\nscala> circt.stage.ChiselStage.emitCHIRRTL(new MyFirrtlModule)\nElaborating design...\nDone elaborating.\nres3: String = ...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"why-doesnt-chisel-tell-me-which-wires-arent-connected",children:"Why doesn't Chisel tell me which wires aren't connected?"}),"\n",(0,s.jsxs)(n.p,{children:["As long as your code uses ",(0,s.jsx)(n.code,{children:"import chisel3._"})," (and not ",(0,s.jsx)(n.code,{children:"import Chisel._"}),"), it does!\nSee ",(0,s.jsx)(n.a,{href:"../explanations/unconnected-wires",children:"Unconnected Wires"})," for details."]}),"\n",(0,s.jsxs)(n.h3,{id:"what-does-reference--is-not-fully-initialized-mean",children:["What does ",(0,s.jsx)(n.code,{children:"Reference ... is not fully initialized."})," mean?"]}),"\n",(0,s.jsx)(n.p,{children:"It means that you have unconnected wires in your design which could be an indication of a design bug."}),"\n",(0,s.jsxs)(n.p,{children:["In Chisel2 compatibility mode (",(0,s.jsx)(n.code,{children:"NotStrict"})," compile options), chisel generates firrtl code that disables firrtl's initialized wire checks.\nIn pure chisel3 (",(0,s.jsx)(n.code,{children:"Strict"})," compile options), the generated firrtl code does not contain these disablers (",(0,s.jsx)(n.code,{children:"is invalid"}),").\nOutput wires that are not driven (not connected) are reported by firrtl as ",(0,s.jsx)(n.code,{children:"not fully initialized"}),".\nRead more at ",(0,s.jsx)(n.a,{href:"../explanations/unconnected-wires",children:"Unconnected Wires"})," for details on solving the problem."]}),"\n",(0,s.jsx)(n.h3,{id:"can-i-specify-behavior-before-and-after-generated-initial-blocks",children:"Can I specify behavior before and after generated initial blocks?"}),"\n",(0,s.jsx)(n.p,{children:"Users may define the following macros if they wish to specify behavior before or after emitted initial blocks."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BEFORE_INITIAL"}),", which is called before the emitted (non-empty) initial block if it is defined"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AFTER_INITIAL"}),", which is called after the emitted (non-empty) initial block if it is defined"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These macros may be useful for turning coverage on and off."})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>r});var s=i(6540);const l={},o=s.createContext(l);function t(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:t(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);